// template-function.cpp by Bill Weinman [bw.org]
// updated 2022-06-04
#include <format>
#include <iostream>
#include <string>

using std::format;
using std::cout;


// this template is both type agnostic and type safe.
// it is type-agnostic becuase it will wotk  for any type that supports greter than(>) operator for comparison
// it is also type-safe because the compiler will genereta a specializition of the function for each given type that uses this function.
// T is a place holder here. You can use antyhing istead of T (like TYPE, XXX, K, E, FOO). but T is more readable. When this maxof function is called then all of Ts in this template function
// will be replaced with the corresponded type. This way the compiler will be creating the psecializtion for that type.
template <typename T>
//template <class T> //same as above line but abovel ie in more readble and less ambigious.. prefer it.
T maxof(T a, T b) {
    return a > b ? a : b;
}

int main() {
    int x {47};
    int y {73};

    // Here we called maxof function.The type we provided in angle brackets( <int>: here int in this case) is corresponds to T in templat function.
    //When compiler see the below code, the compiler will create a maxof function for type "int". We could assume It would be like this:
           /* this is called specializtion. This will be generated by compiler for us using our template function. We won't be seeing it but it wiil be in our compiled code.
            int maxof(int a, int b) {
                return a > b ? a : b;
             }
           */
    auto z = maxof<int>(x, y);
    cout << format("max is {}\n", z);

    cout << format("===================================\n");

    const char* a { "foo" };
    const char* b { "bar" };

    // Here we called maxof function.The type we provided in angle brackets( <const char *>: here const char * in this case) is corresponds to T in template function.
    //When compiler see the below code, the compiler will create a maxof function for type "const char *". We could assume It would be like this:
           /* this is called specializtion. This will be generated by compiler for us using our template function. We won't be seeing it but it will be in our compiled code.
            const char*  maxof(const char * a, const char * b) {
                return a > b ? a : b;
             }
           */
    auto c = maxof<const char *>(a, b);
    cout << format("max is \'{}\'\n", c); // note that this gives "bar" as result. This does not makes sense. But, > operator, when comparing pointers it compares the pointers not the actual strings.



    cout << format("===================================\n");

    std::string o{ "foo" };
    std::string p{ "bar" };

    // Here we called maxof function.The type we provided in angle brackets( <std::string>: here std::string in this case) is corresponds to T in template function.
    //When compiler see the below code, the compiler will create a maxof function for type "std::string". We could assume It would be like this:
           /* this is called specializtion. This will be generated by compiler for us using our template function. We won't be seeing it but it will be in our compiled code.
            std::string  maxof(std::string a, std::string b) {
                return a > b ? a : b;
             }
           */
    auto r = maxof<std::string>(o, p);
    cout << format("max is \'{}\'\n", r); 

    //even we can call this function like this. Omit the ttemplate type from the angle brackets(<>). this will still work because compiler will deducte the type using( template argument deduction process)
    // using the types of the parameters(o and p) we passd in.  therefore all of the lines below. work as expected.
    auto r1 = maxof<>(o, p);
    auto z1 = maxof<>(x, y);
    auto c1 = maxof<>(a, b);
    
    return 0;
}
